// Copyright 2025-2026 Nokia
// Licensed under the BSD 3-Clause License.
// SPDX-License-Identifier: BSD-3-Clause

use std::path::Path;

fn main() {
    #[cfg(feature = "dev")]
    {
        use codegen::Scope;
        use convert_case::{Case, Casing};
        use serde::{
            Deserialize, Serialize,
            de::{DeserializeOwned, Error},
        };
        use serde_json::Value;
        use std::{
            fs::{File, read_to_string},
            io::Write,
        };

        #[cfg(feature = "dev")]
        #[derive(Serialize, Deserialize)]
        struct NodeType {
            #[serde(alias = "type")]
            type_name: String,
            named: bool,
        }

        let tree_sitter_available = std::process::Command::new("tree-sitter")
            .arg("--version")
            .status()
            .is_ok();

        if tree_sitter_available {
            let output = std::process::Command::new("tree-sitter")
                .arg("generate")
                .arg("--abi=14")
                .output()
                .expect("Failed to execute tree-sitter build command");

            if !output.status.success() {
                let error_message = String::from_utf8_lossy(&output.stderr);
                panic!("Tree-sitter build failed: {error_message}");
            }
        }

        // rust codegen
        fn read_to_json<T>(path: &Path) -> Result<T, impl Error>
        where
            T: DeserializeOwned,
        {
            let json_str =
                read_to_string(path).unwrap_or_else(|_| panic!("Failed to read file: {:?}", path));
            serde_json::from_str::<T>(&json_str)
        }

        let nodetype_json_path = Path::new("src/node-types.json");
        println!(
            "cargo:rerun-if-changed={}",
            nodetype_json_path.to_str().unwrap()
        );
        let nodetype_json: Result<Vec<NodeType>, _> = read_to_json(nodetype_json_path);

        let grammar_json_path = Path::new("src/grammar.json");
        println!(
            "cargo:rerun-if-changed={}",
            grammar_json_path.to_str().unwrap()
        );
        let grammar_json: Result<Value, _> = read_to_json(grammar_json_path);

        let mut grammar_scope = Scope::new();
        grammar_scope.doc(
            r#"Copyright 2025-2026 Nokia
Licensed under the BSD 3-Clause License.
SPDX-License-Identifier: BSD-3-Clause

This file is auto-generated by build.rs, which is not intended for manual editing."#,
        );

        grammar_scope.import("strum_macros", "Display");
        grammar_scope.import("strum_macros", "EnumIter");
        grammar_scope.import("strum_macros", "EnumString");
        grammar_scope.import("strum_macros", "IntoStaticStr");

        // enum for rules
        let enum_rule = grammar_scope
            .new_enum("Rule")
            .vis("pub")
            .derive("Clone")
            .derive("Copy")
            .derive("Debug")
            .derive("Display")
            .derive("EnumString")
            .derive("IntoStaticStr")
            .derive("PartialEq");

        for node_type in nodetype_json.unwrap() {
            if !node_type.named
                || matches!(
                    node_type.type_name.as_str(),
                    "continue" | "true" | "false" | "fn" | "let" | "use" | "mod" | "mut"
                )
            {
                // skip those unnamed and reserved
                continue;
            }
            let name = node_type.type_name;
            enum_rule
                .new_variant(name.to_case(Case::Pascal))
                .annotation(format!(r#"#[strum(serialize = "{}")]"#, name));
        }

        // enum for built-ins
        let enum_builtin = grammar_scope
            .new_enum("Builtin")
            .vis("pub")
            .derive("Clone")
            .derive("Copy")
            .derive("Debug")
            .derive("Display")
            .derive("EnumIter")
            .derive("EnumString")
            .derive("IntoStaticStr")
            .derive("PartialEq");

        // TODO: 1. find a better approach
        // TODO: 2. provide the info of parameter count
        let mut grammar_json = grammar_json.unwrap();
        assert!(grammar_json.is_object());
        let grammar_json = grammar_json.as_object_mut().unwrap();
        let rules = grammar_json.get_mut("rules").unwrap();
        assert!(rules.is_object());
        let rules = rules.as_object_mut().unwrap();
        let mut builtins: Vec<(String, String)> = vec![];
        rules.iter().for_each(|(rule_name, rule_entity)| {
            if !rule_name.starts_with("builtin_for") {
                return;
            }
            let members = rule_entity["content"]["members"].as_array().unwrap();
            for member in members {
                let inner_members = member["members"].as_array().unwrap();
                for inner_member in inner_members {
                    let builtin_rule = inner_member.as_object().unwrap();
                    let type_name = builtin_rule["type"].as_str().unwrap();
                    if type_name == "ALIAS" {
                        let builtin_name = builtin_rule["content"]["value"].as_str().unwrap();
                        builtins.push((
                            builtin_name.to_case(Case::Pascal),
                            format!(r#"#[strum(serialize = "{}")]"#, builtin_name),
                        ));
                    }
                }
            }
        });
        builtins.sort_by(|x, y| x.0.cmp(&y.0));
        builtins.iter().for_each(|(enum_name, serial_name)| {
            enum_builtin.new_variant(enum_name).annotation(serial_name);
        });

        let grammar_rs_path = Path::new("bindings").join("rust").join("grammar.rs");
        let mut grammar_rs = File::create(grammar_rs_path).unwrap();
        grammar_rs
            .write_all(grammar_scope.to_string().as_bytes())
            .unwrap();
    }

    let src_dir = Path::new("src");
    let mut c_config = cc::Build::new();
    c_config.std("c11").include(src_dir);

    #[cfg(target_env = "msvc")]
    c_config.flag("-utf-8");
    // Currently the wasm support of tree-sitter is unstable, let's just build the rust binding on host.
    /*
    // detect target
    let target = std::env::var("TARGET").expect("TARGET environment variable not set");
    if target == "wasm32-unknown-unknown" {
        c_config.compiler("emcc");
        //c_config.flag("-s");
        //c_config.flag("WASM=1");
        c_config.flag("-s");
        c_config.flag("SIDE_MODULE=1");
        //c_config.flag("-s");
        //c_config.flag("EXPORTED_FUNCTIONS=['_tree_sitter_freemarker']");
        c_config.flag("--no-entry");
    }
    */

    // tree-sitter parser
    let parser_path = src_dir.join("parser.c");
    c_config.file(&parser_path);
    println!("cargo:rerun-if-changed={}", parser_path.to_str().unwrap());
    // uses an external scanner
    let scanner_path = src_dir.join("scanner.c");
    c_config.file(&scanner_path);
    println!("cargo:rerun-if-changed={}", scanner_path.to_str().unwrap());
    // compile binding package
    c_config.compile("tree-sitter-freemarker");
}
